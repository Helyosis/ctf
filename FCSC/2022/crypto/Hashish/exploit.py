from pwn import *

def twos_comp(val, bits):
    """compute the 2's complement of int value val"""
    sign = -1
    if val  <0:
        sign = 1
        val = -val
    val = val ^ ((2 ** bits) - 1)
    val += 1
    return sign * (val % (2 ** bits))

def partial_hash(t: tuple, nb_iter: int):
    acc = 2870177450012600261
    for i in range(min(nb_iter, len(t))):
        lane = hash(t[i])
        if lane == -1: return -1
        if lane < 0: lane = twos_comp(lane, 64)

        acc += lane * 14029467366897019727
        acc %= 2 ** 64

        acc = (acc << 31) | (acc >> (64 - 31))
        acc %= 2 ** 64

        acc *= 11400714785074694791
        acc %= 2 ** 64

    return acc

def rev_hash(h: int) -> int:
    hash_to_fake = h

    h -= 2 ^ 2870177450012600261 ^ 3527539
    if h < 0:
        h = twos_comp(h, 64)
    h *= pow(11400714785074694791, -1, 2 ** 64)
    h %= 2 ** 64

    h = (h >> 31) | (h << (64 - 31))
    h %= 2 ** 64

    for i1 in range(2 ** 30):
        lane_mul = h - partial_hash((i1, None), 1)
        if lane_mul < 0:
            lane_mul = twos_comp(lane_mul, 64)

        i2 = lane_mul * pow(14029467366897019727, -1, 2 ** 64)
        i2 %= 2 ** 64
        if i2 >> 63 == 1:
            i2 = twos_comp(i2, 64)

        h_ = hash((i1, i2))
        if h_ == hash_to_fake:
            print(f"wanted_hash = {hex(hash_to_fake)}")
            print(f"found hash with i = {i2}: {hex(h_)}")
            assert h_ == hash_to_fake
            return (i1, i2)


if __name__ == '__main__':
    context.log_level = 'error'
    r = remote("challenges.france-cybersecurity-challenge.fr", 2103)

    challenge = int(r.recvline().split()[-1])
    a, b = rev_hash(challenge)

    r.sendline(str(a).encode())
    r.sendline(str(b).encode())

    line_ = r.recvline()
    flag = bytes(eval(line_[8:]))[16:]
    print(flag.decode())