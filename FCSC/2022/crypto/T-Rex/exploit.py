from random import randint
from Crypto.Util.number import long_to_bytes, bytes_to_long
from Crypto.Cipher import AES
from Crypto.Util.Padding import unpad

with open("output.txt", "r") as f:
    iv = bytes.fromhex(f.read(32))
    ct = bytes.fromhex(f.read())

def transform(key: int) -> int:
    M = 2 ** (8 * 16)
    R = lambda x: ((2 * x + 1) * x)
    for _ in range(31337):
        key = R(key) % M
    return key

iv = bytes_to_long(iv)
print("iv =", format(iv, "0128b"))

known_bit = 0
for i in range(128):
    x = int(randint(0, 2 ** 128))
    x = (x >> i) << (i + 1) # Test x with known bit as LSB, 0 in pos i and random in MSB
    x += known_bit
    
    # On teste si le i_ème bit de iv est égal à transform(x)
    print(format(transform(x), "0128b"))    
    print(format(iv, "0128b"))
    print("=" * 128)

    if (transform(x) % (2 ** (i + 1))) == (iv % (2 ** (i + 1))):
        # Matches
        known_bit += 0 * 2 ** i
    else:
        # Doesn't match
        known_bit += 1 * 2 ** i

key = known_bit

cipher = AES.new(long_to_bytes(key), AES.MODE_CBC, iv = long_to_bytes(iv))
print(unpad(cipher.decrypt(ct), 16).decode())