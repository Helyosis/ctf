from pwn import *
from tailor import F, encode, get_random_string
import json, string

context.log_level = 'error'
r = remote("challenges.france-cybersecurity-challenge.fr", 2100)

def pad_sum(to_pad: bytes, T: int, n: int = 8):
    nb_remaining_char = n - len(to_pad)
    s = to_pad
    orig_T = T
    if nb_remaining_char * 0x7f < T: # 0x7f is the highest character possible
        return None
    if sum(list(to_pad)) > T:
        return None
    
    T -= sum(list(to_pad))
    for i in range(nb_remaining_char):
        if T > 0x7f:
            s += b'\x7f'
            T -= 0x7f
        else:
            s += bytes([T])
            T = 0
    
    s = bytes([s[-1]]) + s[:-1] # We can push the last char to the front because it's a unrestricted char
    #print(f"[+] Padded {to_pad} to {s}")
    
    assert sum(list(s)) == orig_T
    return s

def decode(encoded: bytes):
    charset = range(0x7f)
    for T in reverse[str(encoded[0])]:
        for a in charset:
            s = pad_sum(bytes([a]), T)
            if s and encode(s)[1] == encoded[1]:
                for b in charset:
                    s = pad_sum(bytes([a, b]), T)
                    if s and encode(s)[2] == encoded[2]:
                        for c in charset:
                            s = pad_sum(bytes([a, b, c]), T)
                            if s and encode(s)[3] == encoded[3]:
                                for d in charset:
                                    s = pad_sum(bytes([a, b, c, d]), T)
                                    if s and encode(s)[4] == encoded[4]:
                                        for e in charset:
                                            s = pad_sum(bytes([a, b, c, d, e]), T)
                                            if s and encode(s)[5] == encoded[5]:
                                                for f in charset:
                                                    s = pad_sum(bytes([a, b, c, d, e, f]), T)
                                                    if s and encode(s)[6] == encoded[6]:
                                                        for g in charset:
                                                            s = pad_sum(bytes([a, b, c, d, e, f, g]), T)
                                                            if s and encode(s)[7] == encoded[7]:
                                                                yield s




with open("reverse_table.json", "r") as f:
    reverse = json.loads(f.read())

l = r.recvline().strip()
pwd = l[51:-2]
print(l, pwd)

i = 0
for candidate in decode(pwd):
    assert encode(candidate) == pwd
    r.sendline(candidate)
    i += 1

    if i == 8:
        break

r.recvline()
print(r.recvline().decode())